class ViaVerde

  types
  	public String = seq1 of char;
  	  	
    public Car::licensePlate:String
    						carClass:CarClass
    						brandModel:BrandModel;
    						
    public CarClass = <a> | <b> | <c> | <d>;
    
    public BrandModel = <Mercedes> * <Benz> | <Audi> * <A4> | <KIA> * <Leo> | <Hyundai> * <Coupe>
    | <BMW> * <X3> | <Mitsubishi> * <Lancer>;
    
    public ViaVerdeDevice::id:String
    												creditCard:String
    												records:seq of ViaVerdeRecord;

    public ViaVerdeRecord::record:OneTimeRecord | ParkingRecord | HighwayRecord
    											 cost: real;
    												
    public HighwayRecord::entryKm: real
    											exitKm: real
    											entryTime: real
    											exitTime: real
    											direction: Direction
    											highway: String;
    											
    public ParkingRecord::entryTime: real
    											exitTime: real
    											park: String;
    								
    public OneTimeRecord::oneTime: OneTime
    											time: real;
    
    public OneTime = <GasStation> | <SCUT>;
    
    public Highway::costPerClass: inmap CarClass to real
    								costPerTollbooth: inmap Tollbooth to real
    								name: String;
    						 
    public Direction = <Forward> | <Backward>;
    						     												
    public Tollbooth::km: real
    									direction: Direction;
    
  instance variables
  	public highways: inmap String to Highway := { |-> };
  	--Park name -> Cost per hour
  	public parks: inmap String to real := { |-> };   					
  	public registeredCars: inmap Car to ViaVerdeDevice := { |-> };
  	public unRegisteredCarsRecords: map Car to seq of ViaVerdeRecord := { |-> };
  	
  	--All cost, distance and time units >= 0
  	--Entry time/KM < Exit time/KM
  	inv forall highway in set rng highways &
  				forall cpc in set rng highway.costPerClass,
  				cpt in set rng highway.costPerTollbooth & cpc >= 0 and cpt >= 0;
  				
  	inv forall costPerHour in set rng parks & costPerHour >= 0;
  	  	
  	inv forall device in set rng unRegisteredCarsRecords union rng registeredCars &
  				forall vv_record in set elems device.records &
  						validRecordKm(vv_record) and
  						consistentRecordKm(vv_record, rng highways);
  				
    --A car is either registered or unregistered
    inv dom registeredCars inter dom unRegisteredCarsRecords = {};
    
  operations
    public ViaVerde: () ==> ViaVerde
			ViaVerde() == 
				return self;
				
	  public registerCar(car: Car, creditCard: String, id: String) == (
	  	if(car in set dom unRegisteredCarsRecords) then (
		  	registeredCars := registeredCars munion { car |-> mk_ViaVerdeDevice(id, creditCard, unRegisteredCarsRecords(car))};
		  	unRegisteredCarsRecords := {car} <-: unRegisteredCarsRecords 
		 ) else 		   
	  		registeredCars := registeredCars munion { car |-> mk_ViaVerdeDevice(id, creditCard, [])};
	  	return;
	  );
	  
	  public unregisterCar(car: Car) == (
  		unRegisteredCarsRecords := unRegisteredCarsRecords munion { car |-> registeredCars(car).records};
	  	registeredCars := {car} <-: registeredCars;
	  	return;
	  ) pre car in set dom registeredCars;
	  
	  public goThroughHighway(car: Car, entryKm: real, exitKm: real, entryTime: real, exitTime: real, direction: Direction, highway: Highway) == (	
	  	dcl cost: real := (entryKm-exitKm) * highway.costPerClass(car.carClass);
	  	addToRecords(car, mk_ViaVerdeRecord(mk_HighwayRecord(entryKm, exitKm, entryTime, exitTime, direction, highway.name), cost));
	  	return;
	  )
	  pre car in set (dom registeredCars) union (dom unRegisteredCarsRecords) and entryKm < exitKm;	  
	  
	  public goThroughPark(car: Car, entryTime: real, exitTime: real, park: String) == (
	  	dcl cost: real := ((entryTime-exitTime) - (entryTime-exitTime mod 60) div 60) *parks(park);
	  	addToRecords(car, mk_ViaVerdeRecord(mk_ParkingRecord(entryTime, exitTime, park), cost));
	  	return;
	  )
	  pre car in set (dom registeredCars) union (dom unRegisteredCarsRecords) and entryTime < exitTime;
	  
	  public goThroughOneTime(car: Car, cost: real, oneTime: OneTime, time: real) == (	  	
	  	addToRecords(car, mk_ViaVerdeRecord(mk_OneTimeRecord(oneTime, time), cost));
  		return;
	  )
	  pre car in set (dom registeredCars) union (dom unRegisteredCarsRecords);
  
  	public setCreditCard(car: Car, creditCard: String) == (
  		registeredCars(car).creditCard := creditCard;
  		return;
  	)
  	pre car in set dom registeredCars;
  	
  	public addToRecords(car: Car, viaVerdeRecord: ViaVerdeRecord) == (
  		if(car in set dom registeredCars) then
	  		registeredCars(car).records := registeredCars(car).records ^ [viaVerdeRecord]
	  	else 
	  		unRegisteredCarsRecords(car) := unRegisteredCarsRecords(car) ^ [viaVerdeRecord];	  	
  	)
  		
  functions  
  	public retrieveVehicleLocation(licensePlate: String) res: <NotFound> | String*real*real ==
  		<NotFound>;
  								
		public remove[@T](e: @T, s: seq of @T) res: seq of @T ==
    	[s(i) | i in set inds s & s(i) <> e];
    	
    --public removeMap[@T](e: @T, s: map @T to seq of ViaVerdeRecord) res: map @T to seq of ViaVerdeRecord ==
    --	[{ i |-> s(i)} | i in set dom s & s(i) <> e];
  	
  	--Positive distances, entry before exit							
  	private validRecordKm(vv_record: ViaVerdeRecord) res: bool ==
				( is_HighwayRecord(vv_record.record) =>
	  					vv_record.record.entryKm >= 0 and vv_record.record.exitKm >= 0 and
	  					greaterOrZero(vv_record.record.entryKm, vv_record.record.exitKm) ) and
	  		( is_ParkingRecord(vv_record.record) =>
	  					vv_record.record.entryTime >= 0 and vv_record.record.exitTime >= 0 and
	  					greaterOrZero(vv_record.record.entryTime, vv_record.record.exitTime) );
	  
	  --Entry/exit km in records match existing tollbooths		
	  private consistentRecordKm(vv_record: ViaVerdeRecord, highways: set of Highway) res: bool ==
	  		is_HighwayRecord(vv_record.record) =>
	  				exists highway in set highways &
	  						( exists tollbooth in set dom highway.costPerTollbooth &
	  								vv_record.record.entryKm = tollbooth.km and
	  								vv_record.record.direction = tollbooth.direction ) and
	  								
	  						--If client has already exited
	  						vv_record.record.exitKm > 0 =>
			  						( exists tollbooth in set dom highway.costPerTollbooth &
			  								vv_record.record.exitKm = tollbooth.km and
			  								vv_record.record.direction = tollbooth.direction );
	  								
	  private greaterOrZero(first: real, second: real) res: bool ==
	  		second >= first or second = 0;
	  		
end ViaVerde

/*
Como usar:
Configurar run com "console" nesta classe.

Exemplo comandos:
create vv := new ViaVerde()
print vv.registerCar(mk_Car("12-45-AV", <a>, mk_(<Audi>, <A4>)), "1234687854", "1")
*/
  